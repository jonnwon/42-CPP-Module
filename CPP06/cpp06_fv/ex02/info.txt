- A& a = dynamic_cast<A&>(p); 에 대한 설명
    
    
    주어진 코드에서 **`A& a = dynamic_cast<A&>(p);`**는 **`Base`** 클래스에서 파생된 **`p`** 객체를 **`A`** 클래스로 다운캐스트하려는 시도입니다.
    
    - **`dynamic_cast`**를 사용하여 **`p`**를 **`A&`** (A 클래스의 레퍼런스)로 다운캐스트하고 있습니다.
    - **`A& a`**는 이 다운캐스트 결과를 받는 데 사용되는 변수입니다.
    
    만약 **`p`**가 **`A`** 클래스 또는 **`A`** 클래스의 파생 클래스의 인스턴스인 경우, 다운캐스트는 성공하고 **`A& a`**는 **`p`** 객체를 **`A`** 클래스 형식으로 레퍼런싱합니다. 이후 **`std::cout`**을 사용하여 "This is A" 메시지를 출력합니다.
    
    그러나 만약 **`p`**가 **`A`** 클래스 또는 **`A`** 클래스의 파생 클래스가 아닌 다른 클래스의 인스턴스인 경우, 다운캐스트는 실패하고 **`std::bad_cast`** 예외가 발생합니다. 이 예외는 내부적으로 처리되고 아무 동작도 하지 않습니다.
    
    이렇게 다운캐스트를 시도하고 예외 처리를 사용하여 각각의 클래스 형식에 대한 다운캐스트 성공 여부를 확인하고 메시지를 출력하는 방식은 다양한 파생 클래스에 대한 처리를 하나의 함수에서 수행할 때 유용합니다. 다운캐스트가 실패하면 해당 블록을 건너뛰고 다음 블록을 시도할 수 있습니다.
    
    **`A& a = dynamic_cast<A&>(p);`**와 같이 레퍼런스를 선언할 때 **`dynamic_cast`**의 결과를 초기화하는 것이 필요합니다. **`dynamic_cast`**는 다운캐스트가 성공하면 해당 객체에 대한 레퍼런스를 반환하고, 이 레퍼런스를 **`a`**와 같은 변수에 저장하여 사용합니다.


-------------------------------------------------


이번 과제는 dynamic_cast 를 사용해보는 문제다. 

Base 클래스를 상속받는 3개의 자식 클래스를 생성 후에

rand() 함수를 통해 랜덤으로 자식클래스를 통해 객체를 생성하고,
부모 클래스의 포인터로 리턴한다.

이 리턴된 값은 부모 클래스의 포인터 형이기 때문에
이를 다운캐스트하여 어떤 자식클래스인지 확인해보는 함수를 구현하여 
확인해본다

이를 확인하는 함수를 2가지 구현해야 하는데,
매개변수가 포인터인 형태와 레퍼런스인 형태다.

1) void identify(Base* p) 

매개변수가 포인터인 형태는 if / else if / else if 구문과 
dynamic_cast<A*>(p) 같은 조건을 통해 구현하며 


dynamic_cast<A*>(p) 같은 형태에서 다운캐스트가 되었다면 
포인터 p가 갖고있는 주소를 그대로 반환함. 안되었다면 널을 반환함.


Generate C   // C가 생성됨 
p의 주소 : 0x6000001bc030
dynamic_cast<A*>(p) 의 결과 : 0x0
dynamic_cast<B*>(p) 의 결과 : 0x0
dynamic_cast<C*>(p) 의 결과 : 0x6000001bc030



2) void identify(Base& p)
 매개변수가 레퍼런스인 형태는 중첩 try-catch를 사용하게 되는데 이유는
 다음과 같다

서브젝트에서 이 함수는 포인터를 사용해선 안된다고 했으므로 
다운캐스트를 할 때 A& 와 같은 타입으로 다운캐스트 해야한다. 

 dynamic_cast<A&>(p) 
이 형태는 p를 A의 레퍼런스 타입으로 다운캐스트 하게 되는데 
레퍼런스는 반드시 초기화 되어야 함. 

즉, A& a = dynamic_cast<A&>(p) 와 같이 레퍼런스를 선언할 때 
dynamic_cast의 결과를 초기화 하는 것이 필요함.
다운캐스트가 성공하면 해당 객체에 대한 레퍼런스를 반환하고, 이 레퍼런스를
a와 같은 변수에 저장하여 사용하게 됨 



만약 p가 다운캐스트에 실패하면 std::bad_cast 예외가 발생하여 
catch 블록으로 간다. 


---------------------------------------------
즉, dynamic_cast 를 사용해보고 레퍼런스 개념을 복습할 수 있었다.


참고 : std::bad_cast -> 노션
