
C++ 에 직접적으로 존재하지 않는 개념인 Static class 을 구현하라고 한다.

이는 다른 언어(Java 등) 에서 사용되는 개념을 비추어 보았을 때

인스턴스의 생성 없이 클래스 내의 모든 멤버 함수를 사용할 수 있도록 하는 
클래스를 구현하라는 것으로 유추해볼 수 있으며, 인스턴스의 생성은
불필요 하기 때문에 OCCP 를 위해 만든 생성자, 소멸자, 복사생성자, 복사대입연산자 등은 private 에 구현한다. 


과제의 서브젝트에 있는 내용을 따르면 
각 스칼라 타입에 대한 리터럴의 형태가 존재하며 프로그램 실행 시 
입력한 인자가 어떤 리터럴의 형태인지 판단 후 실제 타입으로 (문자열에서 스칼라 타입으로) 변환해야 하며

그 변환한 값을 나머지 3개의 타입으로 변환해야 한다. 

또한, 오버플로우나 변환이 무의미 하면 impossible 문구를 띄운다. 


내가 고민 끝에 내린 결론 .. 
만약 int의 최대값 이상이 문자열로 들어온 경우 
이는 int 리터럴을 의도하고 입력한 것이기 때문에 입력받은 문자열은
int 리터럴로 보는 것이 적절하지만 오버플로우가 발생한다.

오버플로우가 발생한 값을 나머지 3개의 타입으로 변환하는 것은 
무의미 하기 때문에 나머지 값도 impossible 을 띄운다.

즉, 2147483648 과 같은 값을 인자로 받았을 때 

char: impossible
int: impossible
float: 2147483648.0f
double: 2147483648.0 

이 아닌 

char: impossible
int: impossible
float: impossible
double: impossible

이 적절하다고 판단했다. 

-----------------------------------------------

암튼 이 과제는 static_cast를 활용해보고, 
부가적으로 static class 에 대해 알아보며 
가짜의사 (nan, inf 등) 에 대한 지식과 

std::numeric_limits<type>::max() 
std::numeric_limits<type>infinity() 등 을 알게 되었고


삽질 과정에서 
std::istringstream, std::stringstream  을 이용한 문자열 조작을
공부했으며 

함수포인터와 switch 문 등을 복습할 수 있었고, 
적절한 예외클래스를 만들어 예외 객체를 throw 하고
try-catch 블록을 통해 적절히 예외처리 하며 
전체적인 로직을 어떻게 짤지 고민해볼 수 있는 
아~주 귀찮은 문제였다.
gg 
